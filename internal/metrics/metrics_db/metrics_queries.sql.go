// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: metrics_queries.sql

package metricsdb

import (
	"context"
	"database/sql"
	"time"
)

const cleanupExecutionMetrics = `-- name: CleanupExecutionMetrics :exec
DELETE FROM execution_metrics WHERE timestamp < ?
`

func (q *Queries) CleanupExecutionMetrics(ctx context.Context, timestamp time.Time) error {
	_, err := q.db.ExecContext(ctx, cleanupExecutionMetrics, timestamp)
	return err
}

const getDailyUsage = `-- name: GetDailyUsage :many
SELECT
    STRFTIME('%Y-%m-%d', timestamp) as day,
    SUM(prompt_tokens),
    SUM(completion_tokens),
    COUNT(*)
FROM execution_metrics
WHERE timestamp > STRFTIME('%Y-%m-%d %H:%M:%S', ?)
GROUP BY day
ORDER BY day DESC
`

type GetDailyUsageRow struct {
	Day   interface{}
	Sum   sql.NullFloat64
	Sum_2 sql.NullFloat64
	Count int64
}

func (q *Queries) GetDailyUsage(ctx context.Context, strftime interface{}) ([]GetDailyUsageRow, error) {
	rows, err := q.db.QueryContext(ctx, getDailyUsage, strftime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDailyUsageRow
	for rows.Next() {
		var i GetDailyUsageRow
		if err := rows.Scan(
			&i.Day,
			&i.Sum,
			&i.Sum_2,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertExecutionMetric = `-- name: InsertExecutionMetric :exec
INSERT INTO execution_metrics (agent_name, model, prompt_tokens, completion_tokens, latency_ms, timestamp)
VALUES (?, ?, ?, ?, ?, ?)
`

type InsertExecutionMetricParams struct {
	AgentName        string
	Model            string
	PromptTokens     int64
	CompletionTokens int64
	LatencyMs        int64
	Timestamp        time.Time
}

func (q *Queries) InsertExecutionMetric(ctx context.Context, arg InsertExecutionMetricParams) error {
	_, err := q.db.ExecContext(ctx, insertExecutionMetric,
		arg.AgentName,
		arg.Model,
		arg.PromptTokens,
		arg.CompletionTokens,
		arg.LatencyMs,
		arg.Timestamp,
	)
	return err
}
